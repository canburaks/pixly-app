{"version":3,"sources":["../../src/stylelint/preprocessor.js"],"names":["stripAnsi","require","transform","preprocessor","errors","cache","code","input","filename","result","undefined","e","rules","replacements","cssText","Object","keys","forEach","selector","rule","line","split","length","start","displayName","last","pop","column","error","prefix","message","startsWith","replace","loc","find","l","includes","Number","trim","errored","warnings","push","name","text","severity","original","w","end","module","exports"],"mappings":"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","sourcesContent":["/* @flow */\n\nimport type { Replacement } from '../transform';\n\nconst stripAnsi = require('strip-ansi');\nconst transform = require('../transform');\n\ntype Errors = {\n  [key: string]: ?{\n    name?: string,\n    code?: string,\n    message: string,\n    pos?: number,\n    loc?: {\n      line: number,\n      column: number,\n    },\n  },\n};\n\ntype Cache = {\n  [key: string]: ?(Replacement[]),\n};\n\ntype Warning = {\n  rule?: string,\n  text: string,\n  severity: 'error' | 'warning',\n  line: number,\n  column: number,\n};\n\ntype LintResult = {\n  errored: boolean,\n  warnings: Warning[],\n};\n\nfunction preprocessor() {\n  const errors: Errors = {};\n  const cache: Cache = {};\n\n  return {\n    code(input: string, filename: string) {\n      let result;\n\n      try {\n        result = transform(input, {\n          filename,\n        });\n\n        cache[filename] = undefined;\n        errors[filename] = undefined;\n      } catch (e) {\n        cache[filename] = undefined;\n        errors[filename] = e;\n\n        // Ignore parse errors here\n        // We handle it separately\n        return '';\n      }\n\n      const { rules, replacements } = result;\n\n      if (!rules) {\n        return '';\n      }\n\n      // Construct a CSS-ish file from the unprocessed style rules\n      let cssText = '';\n\n      Object.keys(rules).forEach(selector => {\n        const rule = rules[selector];\n\n        // Append new lines until we get to the start line number\n        let line = cssText.split('\\n').length;\n\n        while (rule.start && line < rule.start.line) {\n          cssText += '\\n';\n          line++;\n        }\n\n        cssText += `.${rule.displayName} {`;\n\n        // Append blank spaces until we get to the start column number\n        const last = cssText.split('\\n').pop();\n\n        let column = last ? last.length : 0;\n\n        while (rule.start && column < rule.start.column) {\n          cssText += ' ';\n          column++;\n        }\n\n        cssText += `${rule.cssText} }`;\n      });\n\n      cache[filename] = replacements;\n\n      return cssText;\n    },\n    result(result: LintResult, filename: string) {\n      const error = errors[filename];\n      const replacements = cache[filename];\n\n      if (error) {\n        // Babel adds this to the error message\n        const prefix = `${filename}: `;\n\n        let message = stripAnsi(\n          error.message.startsWith(prefix)\n            ? error.message.replace(prefix, '')\n            : error.message\n        );\n\n        let { loc } = error;\n\n        if (!loc) {\n          // If the error doesn't have location info, try to find it from the code frame\n          const line = message.split('\\n').find(l => l.startsWith('>'));\n          const column = message.split('\\n').find(l => l.includes('^'));\n\n          if (line && column) {\n            loc = {\n              line: Number(\n                line\n                  .replace(/^> /, '')\n                  .split('|')[0]\n                  .trim()\n              ),\n              column: column.replace(/[^|]+\\|\\s/, '').length,\n            };\n          }\n        }\n\n        if (loc) {\n          // Strip the codeframe text if we have location of the error\n          // It's formatted badly by stylelint, so not very helpful\n          message = message.replace(/^>?\\s+\\d?\\s\\|.*$/gm, '').trim();\n        }\n\n        // eslint-disable-next-line no-param-reassign\n        result.errored = true;\n        result.warnings.push({\n          rule: error.code || error.name,\n          text: message,\n          line: loc ? loc.line : 0,\n          column: loc ? loc.column : 0,\n          severity: 'error',\n        });\n      }\n\n      if (replacements) {\n        replacements.forEach(({ original, length }) => {\n          // If the warnings contain stuff that's been replaced,\n          // Correct the line and column numbers to what's replaced\n          result.warnings.forEach(w => {\n            /* eslint-disable no-param-reassign */\n\n            if (w.line === original.start.line) {\n              // If the error is on the same line where an interpolation started, we need to adjust the line and column numbers\n              // Because a replacement would have increased or decreased the column numbers\n              // If it's in the same line where interpolation ended, it would have been adjusted during replacement\n              if (w.column > original.start.column + length) {\n                // The error is from an item after the replacements\n                // So we need to adjust the column\n                w.column +=\n                  original.end.column - original.start.column + 1 - length;\n              } else if (\n                w.column >= original.start.column &&\n                w.column < original.start.column + length\n              ) {\n                // The linter will underline the whole word in the editor if column is in inside a word\n                // Set the column to the end, so it will underline the word inside the interpolation\n                // e.g. in `${colors.primary}`, `primary` will be underlined\n                w.column =\n                  original.start.line === original.end.line\n                    ? original.end.column - 1\n                    : original.start.column;\n              }\n            }\n          });\n        });\n      }\n\n      return result;\n    },\n  };\n}\n\nmodule.exports = preprocessor;\n"],"file":"preprocessor.js"}