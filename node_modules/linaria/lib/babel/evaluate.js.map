{"version":3,"sources":["../../src/babel/evaluate.js"],"names":["generator","require","default","babel","Module","isAdded","requirements","path","some","req","parentPath","resolve","t","binding","scope","getBinding","node","name","isReferenced","kind","result","isImportSpecifier","importDeclaration","source","decl","isSequenceExpression","init","variableDeclarator","id","expressions","length","variableDeclaration","loc","push","start","end","traverse","Identifier","p","module","exports","evaluate","filename","transformer","options","get","isIdentifier","expression","expressionStatement","assignmentExpression","memberExpression","identifier","sort","a","b","line","column","reduce","acc","curr","isImportDeclaration","imports","others","unshift","wrapped","blockStatement","m","dependencies","transform","text","ignore","test","code","plugins","defaults","caller","presets","map","babelOptions","forEach","field","filter","item","Array","isArray","includes","it","transformSync","String","raw","join","value"],"mappings":"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","sourcesContent":["/* @flow */\n\nimport type { PluginOptions } from './utils/loadOptions';\n\nconst generator = require('@babel/generator').default;\nconst babel = require('@babel/core');\nconst Module = require('./module');\n\nconst isAdded = (requirements, path) => {\n  if (requirements.some(req => req.path === path)) {\n    return true;\n  }\n\n  if (path.parentPath) {\n    return isAdded(requirements, path.parentPath);\n  }\n\n  return false;\n};\n\nconst resolve = (path, t, requirements) => {\n  const binding = path.scope.getBinding(path.node.name);\n\n  if (\n    path.isReferenced() &&\n    binding &&\n    binding.kind !== 'param' &&\n    !isAdded(requirements, binding.path)\n  ) {\n    let result;\n\n    switch (binding.kind) {\n      case 'module':\n        if (t.isImportSpecifier(binding.path)) {\n          result = t.importDeclaration(\n            [binding.path.node],\n            binding.path.parentPath.node.source\n          );\n        } else {\n          result = binding.path.parentPath.node;\n        }\n        break;\n      case 'const':\n      case 'let':\n      case 'var': {\n        let decl;\n\n        // Replace SequenceExpressions (expr1, expr2, expr3, ...) with the last one\n        if (t.isSequenceExpression(binding.path.node.init)) {\n          const { node } = binding.path;\n\n          decl = t.variableDeclarator(\n            node.id,\n            node.init.expressions[node.init.expressions.length - 1]\n          );\n        } else {\n          decl = binding.path.node;\n        }\n\n        result = t.variableDeclaration(binding.kind, [decl]);\n        break;\n      }\n      default:\n        result = binding.path.node;\n        break;\n    }\n\n    const { loc } = binding.path.node;\n\n    requirements.push({\n      result,\n      path: binding.path,\n      start: loc.start,\n      end: loc.end,\n    });\n\n    binding.path.traverse({\n      Identifier(p) {\n        resolve(p, t, requirements);\n      },\n    });\n  }\n};\n\nmodule.exports = function evaluate(\n  path: any,\n  t: any,\n  filename: string,\n  transformer?: (text: string) => { code: string },\n  options?: PluginOptions\n) {\n  if (t.isSequenceExpression(path)) {\n    // We only need to evaluate the last item in a sequence expression, e.g. (a, b, c)\n    // eslint-disable-next-line no-param-reassign\n    path = path.get('expressions')[path.node.expressions.length - 1];\n  }\n\n  const requirements = [];\n\n  if (t.isIdentifier(path)) {\n    resolve(path, t, requirements);\n  } else {\n    path.traverse({\n      Identifier(p) {\n        resolve(p, t, requirements);\n      },\n    });\n  }\n\n  const expression = t.expressionStatement(\n    t.assignmentExpression(\n      '=',\n      t.memberExpression(t.identifier('module'), t.identifier('exports')),\n      path.node\n    )\n  );\n\n  // Preserve source order\n  requirements.sort((a, b) => {\n    if (a.start.line === b.start.line) {\n      return a.start.column - b.start.column;\n    }\n\n    return a.start.line - b.start.line;\n  });\n\n  // We'll wrap each code in a block to avoid collisions in variable names\n  // We separate out the imports since they cannot be inside blocks\n  const { imports, others } = requirements.reduce(\n    (acc, curr) => {\n      if (t.isImportDeclaration(curr.path.parentPath)) {\n        acc.imports.push(curr.result);\n      } else {\n        // Add these in reverse because we'll need to wrap in block statements in reverse\n        acc.others.unshift(curr.result);\n      }\n\n      return acc;\n    },\n    { imports: [], others: [] }\n  );\n\n  const wrapped = others.reduce(\n    (acc, curr) => t.blockStatement([curr, acc]),\n    t.blockStatement([expression])\n  );\n\n  const m = new Module(filename);\n\n  m.dependencies = [];\n  m.transform =\n    typeof transformer !== 'undefined'\n      ? transformer\n      : function transform(text) {\n          if (options && options.ignore && options.ignore.test(this.filename)) {\n            return { code: text };\n          }\n\n          const plugins = [\n            // Include these plugins to avoid extra config when using { module: false } for webpack\n            '@babel/plugin-transform-modules-commonjs',\n            '@babel/plugin-proposal-export-namespace-from',\n          ];\n\n          const defaults = {\n            caller: { name: 'linaria', evaluate: true },\n            filename: this.filename,\n            presets: [[require.resolve('./index'), options]],\n            plugins: [\n              ...plugins.map(name => require.resolve(name)),\n              // We don't support dynamic imports when evaluating, but don't wanna syntax error\n              // This will replace dynamic imports with an object that does nothing\n              require.resolve('./dynamic-import-noop'),\n            ],\n          };\n\n          const babelOptions =\n            // Shallow copy the babel options because we mutate it later\n            options && options.babelOptions ? { ...options.babelOptions } : {};\n\n          // If we programmtically pass babel options while there is a .babelrc, babel might throw\n          // We need to filter out duplicate presets and plugins so that this doesn't happen\n          // This workaround isn't full proof, but it's still better than nothing\n          ['presets', 'plugins'].forEach(field => {\n            babelOptions[field] = babelOptions[field]\n              ? babelOptions[field].filter(item => {\n                  // If item is an array it's a preset/plugin with options ([preset, options])\n                  // Get the first item to get the preset.plugin name\n                  // Otheriwse it's a plugin name (can be a function too)\n                  const name = Array.isArray(item) ? item[0] : item;\n\n                  if (\n                    // In our case, a preset might also be referring to linaria/babel\n                    // We require the file from internal path which is not the same one that we export\n                    // This case won't get caught and the preset won't filtered, even if they are same\n                    // So we add an extra check for top level linaria/babel\n                    name === 'linaria/babel' ||\n                    name === require.resolve('../../babel') ||\n                    // Also add a check for the plugin names we include for bundler support\n                    plugins.includes(name)\n                  ) {\n                    return false;\n                  }\n\n                  // Loop through the default presets/plugins to see if it already exists\n                  return !defaults[field].some(it =>\n                    // The default presets/plugins can also have nested arrays,\n                    Array.isArray(it) ? it[0] === name : it === name\n                  );\n                })\n              : [];\n          });\n\n          return babel.transformSync(text, {\n            // Passed options shouldn't be able to override the options we pass\n            // Linaria's plugins rely on these (such as filename to generate consistent hash)\n            ...babelOptions,\n            ...defaults,\n            presets: [\n              // Preset order is last to first, so add the extra presets to start\n              // This makes sure that our preset is always run first\n              ...babelOptions.presets,\n              ...defaults.presets,\n            ],\n            plugins: [\n              ...defaults.plugins,\n              // Plugin order is first to last, so add the extra presets to end\n              // This makes sure that the plugins we specify always run first\n              ...babelOptions.plugins,\n            ],\n          });\n        };\n\n  m.evaluate(\n    [\n      // Use String.raw to preserve escapes such as '\\n' in the code\n      // Flow doesn't understand template tags: https://github.com/facebook/flow/issues/2616\n      /* $FlowFixMe */\n      imports.map(node => String.raw`${generator(node).code}`).join('\\n'),\n      /* $FlowFixMe */\n      String.raw`${generator(wrapped).code}`,\n    ].join('\\n')\n  );\n\n  return {\n    value: m.exports,\n    dependencies: ((m.dependencies: any): string[]),\n  };\n};\n"],"file":"evaluate.js"}